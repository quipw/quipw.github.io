<html><head>
<title>Scope and Overloading</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body
{
     font-family: verdana,arial,helvetica,sans-serif;
     background: white;
     color: black;
}

p,th,td,li,ul,ol {
     font-family: verdana,arial,helvetica,sans-serif;
}
h1 
{  
   font-family: Verdana, Arial, Helvetica, sans-serif; 
   color: navy; 
   padding-top: 15px; 
   padding-bottom: 15px; 
   font-size: 36px;
   border: medium #3300CC solid;

   text-align: center;
}
h2 
{
   font-family: Georgia, "Times New Roman", Times, serif;
}
caption
{
   font-weight: bold;
}

code
{
     font-size: 105%;
     font-family: "Courier New",Courier,monospace;
     color: navy;
}

.navbar 
{  
   font-family: Arial, Helvetica, sans-serif; 
   font-size: 12px;
   text-align: center;
}
.code
{
     font-family: "Courier New", Courier, monospace;
     line-height: 133%;
     font-size: 110%;     
     border: thin navy solid;
     padding: 0.5em 0.5em 0.5em 40px;
     color: navy;
     background-color: #CCCCCC;
     margin:  1em 5em 1em 1em;
}
.segment
{
     font-family: "Courier New", Courier, monospace;
     line-height: 133%;
     font-size: 110%;    
     border: thin navy solid;
     padding: 0.5em 0.5em 0.5em 40px;
     color: navy;
     background-color: #FFFF99;
     margin:  1em 5em 1em 1em;
}
.dos 
{
   font-family: "Courier New", Courier, monospace;
   color: #FFFFFF;
   background-color: #000000;
   width: 75%; 
   padding: 3px 1px 7px 7px;
   font-size: 110%;
; margin: 10px  2em
}
.endlesson 
{
   border: medium navy solid;
   margin-right: 5em;
   padding: 1px 5px 5px 10px;
}
.endheader
{
     font-family: Georgia, "Times New Roman", Times, serif;
     color: navy;
     font-weight: bold;
     font-size: 150%;
}
-->
</style>
</head>
<body text="#000000" bgcolor="#FFFFFF">
<h1>Scope and Overloading</h1>
<p>&nbsp;</p>
<h2>Local Variables</h2>
<p>A variable in a method is called a local variable. We have only seen local 
  variables so far. The <code>count</code> variable in <code>DiceRandomClass roll() 
  </code>method (from the last section) is local to the method. The variable comes 
  into being when declared, and it goes away at the end of the block in which 
  it was declared. (A block is the statements between curly braces.)</p>
<p>Here is the <code>roll</code> method again for your convenience.</p>
<pre class="segment">1)   public static int roll()
2)   {
3)	   int count = generator.nextInt(6) + 1;
4)	   return count;
5)   }
</pre>
<p>&nbsp;</p>
<h2>Scope</h2>
<p>The scope of a variable is the portion of the program in which it exists. The 
  variable <code>count</code> in the code segment above comes into being on line 
  3 and ceases to exist on line 6. We say that <code>count</code> is in scope 
  from line 3 to 5.</p>
<p>We learned earlier that when the control variable is defined in the header 
  of the for loop that it ceases to exist at the end of the loop. We say the variable 
  goes out of scope at the end of the loop or that the control variable is local 
  to the for loop.</p>
<p>&nbsp;</p>
<pre class="segment">1) for (int i = 1, i &lt; 5; i++)
2) {
3)    //statement
4)    //statement
5)    int age = 21;
6)    //statement
7) }
8) System.out.println(i); //syntax error</pre>
<p>In this code fragment, <code>i</code> is created on line 1 and ceases to exist 
  after line 7. After exiting the loop, <code>i</code> no longer exists and line 
  8 will give a syntax error (indicated in Eclipse by a red squiggly line under 
  the <code>i</code>). </p>
<p>The variable <code>age</code> is also a local variable. It is created on line 
  5 and dies at line 7. That is, it goes out of scope at the end of the loop.</p>
<p>&nbsp;</p>
<h3>Scope of Method Parameters</h3>
<p>A parameter passed to a method is local to the method. It is created when the 
  method is called and ceases to exist (goes out of scope) when the method returns 
  to the caller. Look at our <code>min</code> method in MinTest again.</p>
<p>&nbsp;</p>
<pre class="segment">1)  public static int min(int num1, int num2) //method header
2)  {
3)     int minimum = num1;
4)
5)      if (num2 &lt; num1)
6)      {
7)         minimum = num2;
8)      }
9)      return minimum;
10)  }</pre>
<p>&nbsp;</p>
<p>The <code>parameters num1</code> and <code>num2</code> come into being when 
  the method is entered and go out of scope when the method is exited. They are 
  local to the method. <code>minimum</code> is also a local variable that exists 
  from its declaration on line 3 to the end of the method on line 10. If we were 
  to declare a new variable on line 7, it would be local to the if statement and 
  go out of scope after line 8.</p>
<p>&nbsp;</p>
<h2>Overloading</h2>
<p>We said earlier that the <code>abs</code> method in the Math class is an example 
  of overloading. Why did the creators of the language do this? We want to be 
  able to get back the same type of variable that we passed the <code>abs</code> 
  method. A method must always return the same data type. But if we call <code>Math.abs(-45.67)</code>, 
  we want to get back the double 45.67. And when we call <code>Math.abs(25)</code> 
  we want to get back the int 25. We could use different names: absDouble(double 
  x), absInt(int x), absFloat(float x), absLong(long x). But this is cumbersome. 
  Overloading is a better way</p>
<p>Java regards methods with the same name but different number and types of parameters 
  as different methods.</p>
<p>&nbsp;</p>
<p> <span class="segment">public double abs(double a){ ... } </span></p>
<p>is different from </p>
<p><span class="segment">public int abs(int a){ ... }</span><br>
</p>
<p>Java tells which method to invoke by the number and type of the parameters 
  supplied by the caller.</p>
<p>&nbsp;</p>
Look at his example:
<pre class="segment">1)  int intValue = -17;
2)  double doubleValue = -43.75;
3)
4)  //call the method named abs that takes one double
5)  double cost = Math.abs(doubleValue);
6)   
7)  //call the method abs that takes one int
8)  int age = Math.abs(intValue);</pre>
<p>&nbsp;
</p><p>This code calls two entirely different methods both named <code>abs</code>. 
  Line 5 calls the <code>abs</code> method that takes a double parameter. Line 
  8 calls the <code>abs</code> method that takes an int parameter.
</p><p>Look at the <code>Math.max</code> methods in the Math class. There are four 
  methods called max; each takes different parameters types. One takes two doubles, 
  one takes two ints, one takes 2 floats and one takes two longs. 
</p><p>What happens if the parameters are an int and a double?</p>
<pre class="segment">int myInt = 25;
double myDouble = 31.56;


Math.max(myInt, myDouble);</pre>
<p>There is no <code>Math.max</code> method that takes an <code>int</code> and 
  a <code>double</code>. But Java doesn't give up. It looks for a method that 
  will work. Remember that an <code>int</code> can be promoted to a <code>double</code> 
  with no loss of data. So Java promotes <code>myInt</code> to a double and then 
  calls the <code>Math.max</code> method that takes two doubles. 
</p><p>&nbsp;
</p><p>Another heavily overloaded method is the <code>println</code> method from the 
  <code>PrintStream</code> class. This is the method that is invoked when you 
  use <code>System.out.println.</code> There is a version that takes a String 
  parameter, a version that takes a int, a version that takes a double, and many 
  more. Java takes care of which version to call. 
</p><p>&nbsp; 
</p><div class="endlesson">
<p class="endheader">Finishing Up</p>
  <p>That's all for this lesson. </p>
  <p>Be sure to do the posting for this lesson.</p>
  <p>Return to this Module's Things to Do and complete the work for this lesson.</p>
 </div>




</body></html>